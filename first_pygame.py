import sys, pygame
import os
import random

ELEMENT_COLOR = (255, 127, 0)
ELEMENT_COLOR_HIGHLIGHTED = (0, 127, 255)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
FREQUENCY_CLOCK = 3
clock = None
WIDTH = 1000
HEIGHT = 800
PROP = 0.25  # proportion between rectangle width and interval width
# NO_FRAMES = 0
# ALGO_FOLDER = "algorithms/"
# SORT_ALGORITHM = "quicksort"


def draw_element(
    display, arrTexts, pos, width_rectangle, height_reference, is_elevated=False
):
    w = h = width_rectangle
    top_coord = 2 * height_reference + width_rectangle
    left_coord = PROP * width_rectangle * (pos + 1) + width_rectangle * pos
    color = ELEMENT_COLOR
    if is_elevated:
        top_coord = height_reference
        color = ELEMENT_COLOR_HIGHLIGHTED
    pygame.draw.rect(display, color, pygame.Rect(left_coord, top_coord, w, h))
    rect = arrTexts[pos].get_rect()
    rect.center = (left_coord + width_rectangle / 2, top_coord + width_rectangle / 2)
    display.blit(arrTexts[pos], rect)


def get_element_texts(arr, font_text):
    return [font_text.render(str(x), 1, BLACK) for x in arr]


def draw_array(display, arrTexts, width_rectangle, height_reference, poses_elevated=[]):
    display.fill(WHITE)
    for i in range(len(arrTexts)):
        is_elevated = i in poses_elevated
        draw_element(
            display, arrTexts, i, width_rectangle, height_reference, is_elevated
        )
    pygame.display.update()
    # global NO_FRAMES
    # pygame.image.save(display, "algorithms/%s/%04d.png" % (SORT_ALGORITHM, NO_FRAMES))
    # NO_FRAMES += 1


def matrix_comparisons(file_name):
    file_lines = []
    with open(file_name, "r") as f:
        file_lines = f.readlines()
    for i in range(len(file_lines)):
        file_lines[i] = list(map(int, file_lines[i].split()))
    return file_lines


def swap_elements(arr, arrText, i, j):
    arr[i], arr[j] = arr[j], arr[i]
    arrText[i], arrText[j] = arrText[j], arrText[i]


def compare_elements(display, arrTexts, width_reference, height_reference, arr, i, j):
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)
    draw_array(display, arrTexts, width_reference, height_reference, [i, j])
    clock.tick(FREQUENCY_CLOCK)
    if (arr[i] > arr[j] and i < j) or (arr[i] < arr[j] and i > j):
        return False
    return True


def compare_and_swap(display, arrTexts, width_reference, height_reference, arr, i, j):
    swapped = False
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)
    draw_array(display, arrTexts, width_reference, height_reference, [i, j])
    clock.tick(FREQUENCY_CLOCK)
    if (arr[i] > arr[j] and i < j) or (arr[i] < arr[j] and i > j):
        swap_elements(arr, arrTexts, i, j)
        draw_array(display, arrTexts, width_reference, height_reference, [i, j])
        clock.tick(FREQUENCY_CLOCK)
        swapped = True
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)
    return swapped


def simulate_bubblesort(arr, arrTexts, display, width_reference, height_reference):
    for i in range(len(arr)):
        for j in range(len(arr) - i - 1):
            compare_and_swap(
                display, arrTexts, width_reference, height_reference, arr, j, j + 1
            )
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)


def simulate_insertionsort(arr, arrTexts, display, width_reference, height_reference):
    for i in range(1, len(arr)):
        j = i - 1
        while j >= 0 and compare_and_swap(
            display, arrTexts, width_reference, height_reference, arr, j, j + 1
        ):
            j -= 1
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)


def simulate_heapsort(arr, arrTexts, display, width_reference, height_reference):
    # generated by github copilot
    def heapify(arr, arrTexts, display, width_reference, height_reference, n, i):
        largest = i
        l = 2 * i + 1
        r = 2 * i + 2
        if l < n and compare_elements(
            display, arrTexts, width_reference, height_reference, arr, largest, l
        ):
            largest = l
        if r < n and compare_elements(
            display, arrTexts, width_reference, height_reference, arr, largest, r
        ):
            largest = r
        if largest != i:
            compare_elements(
                display, arrTexts, width_reference, height_reference, arr, i, largest
            )
            swap_elements(arr, arrTexts, i, largest)
            heapify(
                arr, arrTexts, display, width_reference, height_reference, n, largest
            )

    n = len(arr)
    for i in range(n, -1, -1):
        heapify(arr, arrTexts, display, width_reference, height_reference, n, i)
    for i in range(n - 1, 0, -1):
        swap_elements(arr, arrTexts, i, 0)
        heapify(arr, arrTexts, display, width_reference, height_reference, i, 0)
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)


def simulate_quicksort(arr, arrTexts, display, width_reference, height_reference):
    # generated by github copilot
    def partition(arr, arrTexts, display, width_reference, height_reference, low, high):
        i = low - 1
        # pivot = arr[high]
        for j in range(low, high):
            if compare_elements(
                display, arrTexts, width_reference, height_reference, arr, j, high
            ):
                i += 1
                if i != j:
                    compare_and_swap(
                        display, arrTexts, width_reference, height_reference, arr, i, j
                    )
        if i + 1 != high:
            compare_and_swap(
                display, arrTexts, width_reference, height_reference, arr, i + 1, high
            )
        return i + 1

    def quicksort(arr, arrTexts, display, width_reference, height_reference, low, high):
        if low < high:
            pi = partition(
                arr, arrTexts, display, width_reference, height_reference, low, high
            )
            quicksort(
                arr, arrTexts, display, width_reference, height_reference, low, pi - 1
            )
            quicksort(
                arr, arrTexts, display, width_reference, height_reference, pi + 1, high
            )

    quicksort(
        arr, arrTexts, display, width_reference, height_reference, 0, len(arr) - 1
    )
    draw_array(display, arrTexts, width_reference, height_reference)
    clock.tick(FREQUENCY_CLOCK)


def simulate_sort_algorithm(arr, alg_name, display):
    # first let us handle the inplace algorithms
    # bubble sort
    width_rectangle = WIDTH / (PROP * len(arr) + PROP + len(arr))
    arr_texts = get_element_texts(
        arr, pygame.font.SysFont("Arial", min(72, int(width_rectangle * 0.8)))
    )
    if alg_name == "bubblesort":
        no_floors = 2  # only for comparison
        height_reference = (HEIGHT - no_floors * width_rectangle) / (no_floors + 1)
        simulate_bubblesort(arr, arr_texts, display, width_rectangle, height_reference)
    if alg_name == "insertionsort":
        no_floors = 2
        height_reference = (HEIGHT - no_floors * width_rectangle) / (no_floors + 1)
        simulate_insertionsort(
            arr, arr_texts, display, width_rectangle, height_reference
        )
    if alg_name == "heapsort":
        no_floors = 2
        height_reference = (HEIGHT - no_floors * width_rectangle) / (no_floors + 1)
        simulate_heapsort(arr, arr_texts, display, width_rectangle, height_reference)

    if alg_name == "quicksort":
        no_floors = 2
        height_reference = (HEIGHT - no_floors * width_rectangle) / (no_floors + 1)
        simulate_quicksort(arr, arr_texts, display, width_rectangle, height_reference)


if __name__ == "__main__":
    pygame.init()
    if len(sys.argv) >= 2:
        SORT_ALGORITHM = sys.argv[1]
    if not os.path.isdir(f"algorithms/{SORT_ALGORITHM}"):
        os.mkdir(f"algorithms/{SORT_ALGORITHM}")
    n_elements = 10
    if len(sys.argv) >= 3:
        n_elements = int(sys.argv[2])

    size = WIDTH, HEIGHT
    screen = pygame.display.set_mode(size)
    arr = [i for i in range(10)]
    random.shuffle(arr)
    clock = pygame.time.Clock()
    simulate_sort_algorithm(arr, SORT_ALGORITHM, screen)
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
